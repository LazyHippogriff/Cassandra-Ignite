CREATE TABLE test.blob_table (
    name text PRIMARY KEY,
    data blob
) WITH bloom_filter_fp_chance = 0.01
    AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'}
    AND comment = ''
    AND compaction = {'class': 'org.apache.cassandra.db.compaction.LeveledCompactionStrategy'}
    AND compression = {'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'}
    AND crc_check_chance = 1.0
    AND dclocal_read_repair_chance = 0.1
    AND default_time_to_live = 0
    AND gc_grace_seconds = 864000
    AND max_index_interval = 2048
    AND memtable_flush_period_in_ms = 0
    AND min_index_interval = 128
    AND read_repair_chance = 0.0
    AND speculative_retry = '99PERCENTILE';





#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int global_max=0;

class fish
{

	public:
		int start;
		int end;
		int is_alive;
		fish * next_fish;

		fish()
		{
		}

		fish(int s, int e)
		{
			start=s;
			end=e;
			is_alive=1;
			next_fish=NULL;
		}



		void print()
		{
			cout<<endl<<"start: "<<start<<endl<<" end: "<<end<<endl<<" is_alive: "<<is_alive<<endl;
		}

};

class critical_section
{
	public:
		fish * first_fish;
		critical_section * next_fish;
		void add_fish(fish * l_fish)
		{
			critical_section *l_add=new critical_section();
			l_add->first_fish=l_fish;

			if(next_fish == NULL)
			{
				next_fish=l_add;
			}

			else
			{
				critical_section * l_temp=next_fish;
				while(l_temp->next_fish!=NULL)
				{
					l_temp=l_temp->next_fish;
				}
				l_temp->next_fish=l_add;
			}

		}


		critical_section()
		{
			first_fish=NULL;
			next_fish=NULL;
		}

		void print_critical_section()
		{
			critical_section * l_temp=next_fish;
			while(l_temp!=NULL)
			{
				l_temp->first_fish->print();
				l_temp=l_temp->next_fish;
			}
		}

		int count_elements(int n)
		{
			int l_count=0;
			if(next_fish==NULL)
				return 0;
			critical_section * l_temp=next_fish;
			while(l_temp!=NULL)
			{
				if(l_temp->first_fish->is_alive==n)
					l_count++;
				l_temp=l_temp->next_fish;
			}
			return(l_count);
		}

		void kill_fishes()
		{
			if(next_fish==NULL)
				return;
			critical_section * l_temp=next_fish;
			while(l_temp!=NULL)
			{
				l_temp->first_fish->is_alive--;
				l_temp=l_temp->next_fish;
			}
		}

		void revive_fish()
		{
			if(next_fish==NULL)
				return;
			critical_section * l_temp=next_fish;
			while(l_temp!=NULL)
			{
				l_temp->first_fish->is_alive++;
				l_temp=l_temp->next_fish;
			}
		}




};

int main()
{
	cout<<endl<<"Enter the number of fishes: ";
	int n;
	cin>>n;
	cout<<endl<<"Enter the length of each fish: ";
	vector<int> length;
	for (int i= 0; i< n; i++)
	{
		int temp;
		cin>>temp;
		length.push_back(temp);
	}

	cout<<endl<<"Enter the time for each fish: ";
	vector<int>time;
	for (int i= 0; i< n; i++)
	{
		int temp;
		cin>>temp;
		time.push_back(temp);
	}
	vector<fish> l_fish;
	for (int i= 0; i< n; i++)
	{
		fish temp_fish(time[i], time[i]+length[i]);
		l_fish.push_back(temp_fish);
	}

	vector<int>end_points;
	for (int i= 0; i< n; i++)
	{
		end_points.push_back(l_fish[i].end);
	}

	sort(end_points.begin(), end_points.end());
	vector<critical_section> critical_sections;
	int prev=-999;
	for(int i=0; i<end_points.size();i++)
	{
		if(prev!=end_points[i])
		{
			critical_section * temp = new critical_section();
			prev=end_points[i];
			for (int j=0;j<n;j++)
			{
				if(l_fish[j].start<=end_points[i] && l_fish[j].end>=end_points[i])
				{
					temp->add_fish(&l_fish[j]);
				}

			}
			critical_sections.push_back(*temp);
		}
	}

	for(int i=0; i<critical_sections.size()-1;i++)
	{
		int local_max=0;

		critical_sections[i].kill_fishes();

		local_max+=critical_sections[i].count_elements(0);

		for(int j=1;j<critical_sections.size();j++)
		{
			int l_temp_count=local_max;
			l_temp_count+=critical_sections[j].count_elements(1);
			if(l_temp_count>global_max)
				global_max=l_temp_count;
		}


		critical_sections[i].revive_fish();

	}
	cout<<"global max: "<<global_max;
	return 0;
}
